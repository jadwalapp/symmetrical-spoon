\chapter{Implementation and Testing}

Jadwal is a fast, and efficient system. It uses technologies that allows it to deliver those promises. The fact that Golang is the main language and that the language is compiled.

\section{Technologies and Tools Used}

Jadwal is built using a carefully selected stack of languages, technologies, and tools that enable fast iteration, strong security, ease of development, and deployment flexibility. Every choice made reflects our priority for speed, maintainability, and a high-quality user experience.

\subsection{Backend}

\begin{itemize}
    \item \textbf{Golang} – The main language used in the backend. It is a compiled language that generates native machine code (not bytecode), providing high performance and low overhead. Go also supports cross-compilation, meaning we can build binaries for different platforms (macOS, Linux, Windows) and architectures (x86, arm64) without requiring physical access to those systems. This was essential for our CI/CD and deployment process.
    \item \textbf{ConnectRPC} – The RPC framework we used to define our API. It is highly efficient and uses Protocol Buffers (protobuf) for serialization. This improves communication speed and ensures a consistent, type-safe interface between backend and frontend.
    \item \textbf{sqlc} – A Go-based SQL compiler. Unlike traditional ORMs that abstract SQL (and often add unnecessary complexity), sqlc lets us write raw SQL while still generating typed Go code. This gives us type safety and full SQL control — the best of both worlds.
    \item \textbf{migrate} – Used to handle schema migrations. Written in Go, it allows us to create up/down migration files and execute them at runtime. We also automated it to run at app startup, making database updates smoother during deployment.
    \item \textbf{RabbitMQ} – Our message broker used to decouple the WhatsApp message extraction service from the backend logic. It provides robust, asynchronous communication with delivery guarantees, retries, and scaling potential.
    \item \textbf{OpenAI-based LLM API} – Used in our event extraction pipeline to analyze and classify incoming WhatsApp messages. The abstraction allows easy model switching in the future without changing core logic.
    \item \textbf{HTTPJ} – A REST utility server that handles lightweight jobs like `.mobileconfig` file downloads. While not a central component, it simplifies small tasks that don’t need full RPC wiring.
    \item \textbf{Baikal} – An open-source CalDAV server written in PHP. It handles calendar data storage and sync and was reused in our system to provide a standards-based calendar integration layer.
\end{itemize}

\subsection{Frontend (iOS)}

\begin{itemize}
    \item \textbf{SwiftUI} – The framework used to build the iOS UI. It offers declarative, responsive UI development and is well-suited for small teams due to its simplicity.
    \item \textbf{EventKit} – Apple's official framework for accessing and managing calendar data on-device. It is used to read events, create prayer reminders, and add WhatsApp-parsed events.
    \item \textbf{Xcode} – Apple's IDE used to build, test, and debug the app. Also used for handling provisioning profiles and release builds.
    \item \textbf{JWT (JSON Web Token)} – Used for stateless authentication. Each user receives a signed token after login, which includes their identity (email/user\_id) and is verified using digital signatures to prevent tampering.
    \item \textbf{APNs (Apple Push Notification Service)} – Used to send push notifications for new events, conflicts, and reminders. We collect device IDs and securely store them to trigger these updates.
\end{itemize}

\subsection{WhatsApp Service (Wasapp)}

\begin{itemize}
    \item \textbf{TypeScript} – The main language for the Wasapp service.
    \item \textbf{bun.sh} – Used as our runtime for TypeScript — fast, modern, and integrates well with our stack.
    \item \textbf{Fastify} – A high-performance Node.js framework used to expose an API to the backend from the Wasapp service.
    \item \textbf{whatsapp-web.js} – JS client library that connects to WhatsApp Web, receives messages in real time, and emits events. This is the heart of our message extraction logic.
\end{itemize}

\subsection{Infrastructure, Deployment, and DevOps}

\begin{itemize}
    \item \textbf{Docker} – Everything runs in containers: backend, Wasapp, CalDAV, etc. This enables consistent environments between dev and production.
    \item \textbf{Docker Compose} – Used to orchestrate services locally and during staging. Ensures that every developer gets the same setup out of the box. We used overlays, to override values between production and local environment along with `.env' files.
    \item \textbf{Traefik} – Our reverse proxy/load balancer/API gateway. It integrates with Docker, automatically issues SSL certs via Let's Encrypt, and handles SSL termination (internal services communicate over HTTP for performance).
    \item \textbf{GitHub} – Our version control system, CI/CD pipeline, and GitOps source of truth.
    \begin{itemize}
        \item \textbf{GitHub Actions} – CI workflows for building, testing, and pushing Docker images to GitHub Packages.
        \item \textbf{GitHub Packages} – Our Docker registry. Stores built images and lets us pull them easily on the server.
        \item \textbf{BlackSmith} – A third-party CI runner provider that gives us faster runners at lower cost. Speeds up builds and saves credits.
    \end{itemize}
    \item \textbf{Cloudflare} – Handles DNS, provides DDoS protection, serves as our CDN edge, and allows cheap domain registration. We also use it to force HTTPS and cache public assets.
    \item \textbf{Taskfile} – A Go-based task runner. We use it to alias common dev commands, test scripts, and deploy workflows into short commands.
\end{itemize}

\subsection{Database and Security}

\begin{itemize}
    \item \textbf{PostgreSQL} – Our main database. Used to store customers, calendar connections, event metadata, WhatsApp messages, device IDs, and more.
    \item \textbf{Beekeeper Studio} – A SQL GUI that lets us explore, debug, and visualize our PostgreSQL database. Used frequently during development.
    \item \textbf{Encryption at Rest (WhatsApp)} – We encrypt WhatsApp messages before storing them to protect user privacy in the case of a breach or access by other services.
    \item \textbf{Scratch Docker Images} – Our Go binaries are compiled statically and run inside Docker images built `FROM scratch`, meaning the containers are literally empty — no shell, no package manager, nothing for an attacker to exploit.
\end{itemize}

\subsection{Design, Documentation, and Diagrams}

\begin{itemize}
    \item \textbf{LaTeX} – Used to write this entire report. It handles figure references, bibliography, equation rendering, and allows us to store the report in version control for collaboration.
    \item \textbf{PlantUML} – Used to make sequence and class diagrams using plain text that can be rendered as SVG or PNG.
    \item \textbf{Mermaid} – Used for Gantt charts and simple flow diagrams, especially in markdown files and web-based previews.
    \item \textbf{Draw.io} – Used when text-based tools are too limited. We still track the `.drawio` files in GitHub for versioning.
    \item \textbf{UMLet} – Lightweight UML diagram tool used to make clean use case diagrams.
\end{itemize}

\subsection{Design and Productivity Tools}

\begin{itemize}
    \item \textbf{Figma} – Used to design our app logo, UI mockups, and presentation slides.
    \item \textbf{VS Code} – Our primary code editor. Supports extensions, Git integration, LaTeX building, and everything else we needed.
    \item \textbf{Linear} – Used for high-level project planning. Initially we tried micro-planning with it, but the project moved too quickly. We stuck to major task tracking and daily syncs.
    \item \textbf{Resend} – A transactional email service. We use it to send welcome emails, magic links, and other system emails. It has a generous free tier and works reliably.
    \item \textbf{PostHog} – A powerful analytics tool that tracks usage funnels, sessions, and user behavior. It enabled us to see session replays and understand user flows without asking users directly.
\end{itemize}

\section{System Architecture (Implemented)}

The system architecture, as originally outlined in Figure \ref{fig:architecture}, was implemented using a modular, containerized structure. All core components were packaged as separate services and deployed using Docker Compose on a single host. These include the backend service (Falak), the WhatsApp service (Wasapp), the CalDAV server (Baikal), a PostgreSQL database, and a Traefik proxy for HTTPS termination and service routing.

While the design envisioned a distributed system, the final implementation runs on a single host with isolated containers communicating over internal Docker networks. This setup preserves modularity and mirrors real-world deployment environments, while simplifying development and debugging. Each service is decoupled and can be scaled independently in future production-grade deployments.

The implemented architecture maintained full alignment with the original design, with minor practical adjustments such as unified logging using Grafana + Loki, simplified internal networking, and local queues (RabbitMQ) for event-driven flows. Overall, the implementation delivered on the designed goals of modularity, maintainability, and separation of concerns.


\section{Database Implementation}

The original database design, illustrated in Figure~\ref{fig:er-diagram} and Figure~\ref{fig:relational-schema}, was adapted during the actual system implementation. Initially, we planned to manage calendar storage directly within our own database schema. However, during development, we decided to integrate Baikal — an open-source, self-hosted CalDAV server — to handle calendar data following the CalDAV standard.

As a result, several tables from the original ERD were removed or replaced. The Falak backend continues to manage user accounts, authentication methods, WhatsApp message extraction, device IDs, and notification tracking, while Baikal independently handles all calendar-related storage.

The updated database design for the Falak backend, reflecting these changes, is shown in Figure~\ref{fig:updated-er-diagram} and Figure~\ref{fig:updated-relational-schema} below.

\begin{figure}[!h]
    \centering
    \includegraphics[width=0.9\textwidth]{images/docs/diagrams/er/new-database/Updated Falak ERD.png}
    \caption{Updated Entity-Relationship Diagram (Falak)}
    \label{fig:updated-er-diagram}
\end{figure}

% TODO: make this a relational one with draw.io, based on the one above :D
% \begin{figure}[!h]
%     \centering
%     \includegraphics[width=\textwidth]{images/updated-database-schema-relational.png}
%     \caption{Updated Relational Schema (Falak)}
%     \label{fig:updated-relational-schema}
% \end{figure}

\subsection{Baikal Database Schema}

To handle calendar event storage, we integrated Baikal directly without modifying its schema. Baikal follows WebDAV and CalDAV standards and manages calendars, events, user principals, and contact address books internally.

The key Baikal tables relevant to Jadwal's functionality are summarized below:

\begin{itemize}
    \item \textbf{calendars} — Stores metadata for user calendars.
    \item \textbf{calendarobjects} — Stores individual calendar events in iCalendar format.
    \item \textbf{calendarinstances} — Links calendars to user principals.
    \item \textbf{principals} — Represents authenticated users within Baikal.
\end{itemize}

Other tables related to address books, scheduling, and WebDAV-specific functionality (e.g., locks, subscriptions) were unused in our implementation. Baikal's database provided a mature and reliable backend for event storage without requiring us to reinvent a full calendar system.


\section{Implementation of Core Functionalities}

\subsection{Authentication}
The authentication flow supports both magic links (email-based) and Google OAuth. Users receive a signed JWT upon login, which is used for subsequent requests. We generate access tokens (short-lived) and refresh tokens (long-lived), stored securely on the device. Magic tokens are hashed using SHA-256 before being stored in the database. For added security, we implemented logout by invalidating the refresh token, and all tokens are verified using digital signatures. The login flow is stateless and scalable, and was implemented using ConnectRPC endpoints from the iOS client.

\subsection{Connect WhatsApp}
\subsection{Calendar Integration}
\subsection{Prayer Time Scheduling}
\subsection{WhatsApp Event Extraction}
\subsection{Conflict Resolution}
\subsection{Notification System}

\section{Testing Methodology}

We adopted a pragmatic testing methodology focused on verifying key user flows rather than exhaustive unit testing. The most critical paths — such as user login, WhatsApp connection, event parsing, and calendar sync — were tested manually and programmatically during development. We also integrated PostHog for session replay and funnel analytics, which allowed us to observe real user interactions and validate expected behavior. Although full test automation was not implemented, our iterative development approach ensured that all major regressions were caught early.

\section{Tested Features}

Testing is a crucial part of any high quality software. We made sure to test the critical paths of the users making sure they get delivered a high quality experience. We chose to test the authentication flow, the connect WhatsApp flow, the connect calendar flow, the schedule prayer times flow and the WhatsApp event extraction flow. This sums us the important flows in our app. Below each of those flows/features is put through a few tests to ensure quality of the product is what the user expects.

\subsection{Authentication (Email \& Google)}
\subsection{Connect WhatsApp}
\subsection{Connect Calendar}
\subsection{Schedule Prayer Times}
\subsection{WhatsApp Event Extraction}

\section{Comparison to Original Specification}

During implementation, we made several changes to the original design while keeping the core goals of Jadwal intact. Some functional flows, such as calendar event management, were re-implemented using Baikal instead of a custom schema. Others, like WhatsApp event extraction and prayer time scheduling, were refined to better match technical feasibility and real user needs. While the internal structure of the system evolved significantly, especially in database design and service architecture, all critical functionalities promised in the original specification — authentication, event integration, scheduling, and notifications — were delivered. These changes were necessary to produce a system that is secure, maintainable, and production-ready.

\section{Runtime Evaluation}

Jadwal was built with speed, efficiency, and low-latency user experience in mind. The backend, implemented in Go, is compiled into a single native binary, resulting in fast startup and low memory usage. Our API calls typically respond in under 1 second under normal conditions. Calendar events are fetched and parsed quickly, and WhatsApp message processing is handled asynchronously via RabbitMQ to avoid blocking operations. The use of stateless authentication (JWT) and local caching ensures smooth performance on the mobile app, even in poor network conditions. Overall, the system met or exceeded our original performance expectations.
