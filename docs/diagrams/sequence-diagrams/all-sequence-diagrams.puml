@startuml Continue with Email
actor User
participant Backend
database Database
participant EmailServer

activate User

User -> Backend ++ : InitiateEmail

Backend -> Database ++ : CreateCustomerIfNotExists
note right of Database : Customer record is always returned.\nIf custoemr doesn't exist, customer\nis created first then returned.
Database --> Backend -- : Customer

Backend -> Backend : Generate Magic Token and its Hash

Backend -> Database ++ : CreateMagicLink(hashed magic token)
Database --> Backend -- : MagicLink

Backend -> EmailServer ++ : SendMagicLink(normal)
EmailServer --> Backend -- : Email Sent Response

Backend --> User -- : Email Sent Response

User -> User : Opens Email And Clicks Magic Link

User -> Backend : CompleteEmail(MagicToken)

Backend -> Backend : Hash MagicToken

Backend -> Database : Get Magic Link by HashedToken
alt MagicLink exists
    Backend -> Backend : Check (Hashed MagicToken == Hashed MagicToken from Database)
    alt Auth Success
        Backend -> Backend : Issue JWT
        Backend --> User : JWT (Access Token)
    else Auth Failure
        Backend --> User : Permission Denied
    end
else MagicLink doesn't exist
    Database --> Backend : ErrNoSqlRowsFound
    Backend --> User : PermissionDenied
end

deactivate User
@enduml

@startuml Continue with Google
actor User
participant GoogleAuth
participant Backend
database Database

activate User

User -> GoogleAuth ++ : GetAccessToken
GoogleAuth --> User : AccessToken

User -> Backend ++ : UseGoogle(AccessToken)
Backend -> GoogleAuth : GetUserInfoByToken
alt Token Valid
    GoogleAuth --> Backend -- : UserInfo
    
    Backend -> Database ++ : CreateCustomerIfNotExist
    Database --> Backend : Customer

    Backend -> Database : CreateAuthGoogleIfNotExist(UserInfo.sid)
    note right of Database : Customer record is always returned.\nIf custoemr doesn't exist, customer\nis created first then returned.
    Database --> Backend  -- : AuthGoogle

    Backend -> Backend : Check AuthGoogle.sid == UserInfo.sid
    alt Auth Success
        Backend -> Backend : Issue JWT
        Backend --> User : JWT (Access Token)
    else Auth Failure
        Backend --> User : Permission Denied
    end
else Token Invalid
    GoogleAuth --> Backend : GetUserInfoByToken Error
    Backend --> User -- : Permission Denied
end

@enduml

@startuml Send Welcome Email
actor System
participant EmailServer
database Database

activate System

System -> Database ++ : FetchUserInfo

Database --> System -- : UserData

System -> System : Get Magic Link Template
System -> System : Fill Magic Link Template by UserData

System -> EmailServer ++ : SendEmail(Filled Magic Link Template)
EmailServer --> System -- : EmailSentResponse

@enduml

@startuml Logout
actor User

activate User

User -> User : Delete JWT from device

@enduml

@startuml Connect Calendar
actor User
participant "iOS App" as App
participant EventKit
participant "iOS Calendar System" as iOS
participant Backend
database Database

User -> App: Request Calendar Access
App -> EventKit: Request Authorization
EventKit --> App: Authorization Status

alt Authorization Granted
    App -> Backend: Get CalDAV Credentials
    Backend -> Database: Fetch CalDAV Account
    Database --> Backend: Account Credentials
    Backend --> App: CalDAV Credentials

    App -> iOS: Configure CalDAV Account
    note right of iOS: iOS handles all CalDAV\ncommunication directly
    iOS --> App: Account Configuration Status

    App -> EventKit: Fetch Calendar Events
    EventKit -> iOS: Get Events from All Sources
    iOS --> EventKit: Calendar Events
    EventKit --> App: Calendar Events

    App -> App: Schedule Local Notifications
else Authorization Denied
    App --> User: Show Permission Error
end

@enduml

@startuml "Create Calendar"
title Create Calendar

actor User
participant "App" as App
participant "iOS" as iOS

User -> App: Create Calendar Request
activate App

App -> iOS: Create Calendar via EventKit
activate iOS

iOS --> App: Calendar Creation Status
deactivate iOS

App --> User: Display Creation Status
deactivate App

@enduml

@startuml Connect WhatsApp
actor User
participant Backend
participant WhatsApp
database Database

activate User

User -> Backend ++ : InitiateWhatsApp(phone number)

Backend -> WhatsApp ++ : RequestLinkingCode
alt RequestLinkingCode Success
    WhatsApp --> Backend : RequestLinkingCode Succeeded
    Backend -> User -- : InitiateWhatsApp Succeeded

    User -> User : Get Linking Code from WhatsApp

    User -> Backend ++ : CompleteWhatsApp(Linking Code)
    Backend -> WhatsApp : SendLinkingCode
    alt SendLinkingCode Success
        WhatsApp --> Backend : SendLinkingCode Succeeded
        Backend -> Database ++ : Store WhatsAppAuthCreds for Future Use
        Database --> Backend -- : Stored WhatsAppAuthCreds Successfully
        Backend --> User : CompleteWhatsApp Succeeded
    else SendLinkingCode Failure
        WhatsApp --> Backend : SendLinkingCode Failed
        Backend --> User : CompleteWhatsApp Failed
    end
else RequestLinkingCode Failure
    WhatsApp --> Backend -- : RequestLinkingCode Failed
    Backend --> User -- : InitiateWhatsApp Failed
end

deactivate User
@enduml

@startuml Extract Events from WhatsApp
actor "WhatsApp Service\n(uses whatsapp-web.js)" as WhatsApp
participant Backend
participant "LLM Service" as LLM
database Database
participant "Apple Push Notification service (APNs)" as APN
participant "iOS App\n(Background)" as App
participant "iOS" as iOS

activate WhatsApp
loop Listen for Messages
    note over WhatsApp: Client receives\nnew message and waits\n30 seconds for context

    WhatsApp -> WhatsApp: Get last 15 messages\nfrom chat context
    
    WhatsApp ->> Backend ++: Send messages context\nfor analysis

    Backend -> LLM ++: Send context with engineered prompt\nfor event extraction
    note right of LLM: Prompt designed to:\n- Identify events\n- Extract date, time, location\n- Handle informal language\n- Return structured JSON
    
    alt Event Found
        LLM --> Backend: Return Event JSON
        
        Backend -> Backend: Validate extracted\nevent information
        
        Backend -> Database ++: Store Event
        Database --> Backend: Confirm Storage

        Backend -> Database: Get Device IDs of Event Owner
        Database --> Backend --: Return Device IDs
        
        Backend -> APN ++: Send Silent Push Notification\nwith new event details
        APN --> Backend --: Notification Result
        deactivate Backend
        
        APN -> App: Deliver Silent Push Notification
        activate App
        
        App -> iOS: Fetch Calendar Events via EventKit
        activate iOS
        iOS --> App: Calendar Events
        deactivate iOS
        
        App -> App: Check for Conflicts with\nnew WhatsApp event
        
        alt Conflicts Found
            App -> App: Schedule Local Notification\nabout Conflict
            note right: Shows conflict details\nand resolution options
        end
        
        deactivate App
        
    else No Event Detected
        LLM --> Backend --: No Event Found
        deactivate Backend
        note over WhatsApp: Continue monitoring\nmessages
    end
end

@enduml

@startuml Suggest Conflict Resolutions
title Suggest Conflict Resolutions

actor User
participant "App" as App
participant "iOS" as iOS
participant Backend
participant "Apple Push Notification service (APNs)" as APN

User -> App: Open Calendar View
activate App

App -> iOS: Fetch Calendar Events via EventKit
activate iOS
iOS --> App: Calendar Events
deactivate iOS

App -> App: Check for Conflicts
note right
  Checks for:
  1. Time overlap between events
  2. Available alternative time slots
end note

alt Conflicts Found
    App -> App: Generate Resolution Options
    note right
      Options are:
      1. Move event to another time slot
      2. Keep both with conflict warning
    end note

    App --> User: Display Conflict Alert

    alt User Chooses to Resolve
        User -> App: Select Resolution Option
        
        App -> iOS: Modify Event via EventKit
        activate iOS
        iOS --> App: Event Update Status
        deactivate iOS

        alt Event Updated Successfully
            App -> Backend: Log Resolution for Analytics
            Backend --> App: Logging Confirmed
            
            App -> APN: Send Notification about Resolution
            APN --> App: Notification Status
        end
    else User Keeps Conflict
        App -> App: Mark Conflict as Acknowledged
    end
end

deactivate App

@enduml

@startuml Manage Scheduling Conflicts
title Manage Scheduling Conflicts

actor User
participant "App" as App
participant "iOS" as iOS
participant Backend
participant "Apple Push Notification service (APNs)" as APN

User -> App: View Calendar
activate App

App -> iOS: Fetch Events via EventKit
activate iOS
iOS --> App: Calendar Events
deactivate iOS

App -> App: Detect Conflicts
App --> User: Display Conflicts with Options

alt User Selects Resolution
    User -> App: Choose Resolution Option
    
    App -> iOS: Update Event via EventKit
    activate iOS
    iOS --> App: Update Status
    deactivate iOS
    
    alt Update Successful
        App -> Backend: Log Resolution
        Backend --> App: Logging Confirmed
        
        App -> APN: Send Resolution Notification
        APN --> App: Notification Status
        
        App --> User: Show Success Message
    else Update Failed
        App --> User: Show Error Message
    end
else User Ignores Conflict
    App -> App: Mark Conflict as Acknowledged
end

deactivate App

@enduml

@startuml Add Event Manually
actor User
participant Backend
database Database
participant "Apple Push Notification service (APNs)" as APN

activate User

User -> Backend ++ : CreateEvent(eventDetails)

Backend -> Backend : ValidateEventDetails
alt Validation Success
    Backend -> Database ++ : StoreEvent
    Database --> Backend -- : EventStored
    
    Backend -> Backend : CheckForConflicts
    opt Conflicts Found
        Backend -> Database ++ : Ask For Device IDs Of Customer Owning Event
        Database --> Backend -- : Device IDs of Customer Owning Event
        
        Backend -> APN ++ : Send Push Notification "New Conflict Detected" to Device IDs
        APN --> Backend -- : Push Notification Sending Result
    end
    
    Backend --> User : EventCreated
else Validation Failed
    Backend --> User : ValidationError
end

deactivate User

@enduml

@startuml "View Integrated Calendar"
title View Integrated Calendar

actor User
participant "App" as App
participant "iOS" as iOS

User -> App: Open Calendar View
activate App

App -> iOS: Request Calendar Events via EventKit
activate iOS

iOS --> App: Return Calendar Events
deactivate iOS

App -> App: Process and Format Events

App --> User: Display Integrated Calendar View

User -> App: Interact with Calendar
activate App

App -> iOS: Fetch Updated Events (if needed)
activate iOS

iOS --> App: Return Updated Events
deactivate iOS

App --> User: Update Calendar View
deactivate App

@enduml

@startuml Schedule Prayer Times
actor User
participant Backend
participant "Prayer Times API" as PrayerTimesAPI
database Database

activate User
User -> Backend ++ : EnablePrayerTimeScheduling

Backend -> PrayerTimesAPI ++ : Fetch Prayer Times by User's Timezone
PrayerTimesAPI --> Backend -- : PrayerTimes

Backend -> Database ++ : Create Events to Block Times of Prayer
Database --> Backend -- : Creation Response

Backend --> User : EnablePrayerTimeScheduling Response

@enduml

@startuml Receive Event Notifications
actor System
database Database
participant "Apple Push Notification service (APNs)" as APN

activate System

loop Poll Every One Minute
    System -> Database ++ : Check Alarms Set for Events
    Database --> System : Return Active Alarms
    alt Active Alarms Found
        System -> Database : Ask For Device IDs Of Customer Owning Event
        Database --> System -- : Device IDs of Customer Owning Event
        
        loop For Every Event
            System -> APN ++  : Send Push Notification to Device IDs
            APN --> System -- : Push Notification Sending Result
        end
    else No Active Alarms
        note over System,Database : Continue Polling
    end
end

@enduml