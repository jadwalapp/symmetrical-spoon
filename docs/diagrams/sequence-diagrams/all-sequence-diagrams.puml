@startuml Continue with Email
actor User
participant Backend
database Database
participant EmailServer

activate User

User -> Backend ++ : InitiateEmail

Backend -> Database ++ : CreateCustomerIfNotExists
note right of Database : Customer record is always returned.\nIf customer doesn't exist, customer\nis created first then returned.
Database --> Backend -- : Customer

Backend -> Backend : Generate Magic Token and its Hash

Backend -> Database ++ : CreateMagicToken(hashed magic token)
Database --> Backend -- : MagicToken

Backend -> Backend : Make Magic Link by Adding Magic Token to it

Backend -> EmailServer ++ : SendMagicLink(normal)
EmailServer --> Backend -- : Email Sent Response

Backend --> User -- : Email Sent Response

User -> User : Opens Email And Clicks Magic Link

User -> Backend : CompleteEmail(MagicToken)

Backend -> Backend : Hash MagicToken

Backend -> Database : Get Magic Link by HashedToken
alt MagicLink exists
    Backend -> Backend : Check (Hashed MagicToken == Hashed MagicToken from Database)
    alt Auth Success
        Backend -> Backend : Issue two JWTs (Access Token & Refresh Token)
        Backend --> User : JWTs (Access Token & Refresh Token)
    else Auth Failure
        Backend --> User : Permission Denied
    end
else MagicLink doesn't exist
    Database --> Backend : ErrNoSqlRowsFound
    Backend --> User : PermissionDenied
end

deactivate User
@enduml

@startuml Continue with Google
actor User
participant GoogleAuth
participant Backend
database Database

activate User

User -> GoogleAuth ++ : GetAccessToken
GoogleAuth --> User : AccessToken

User -> Backend ++ : UseGoogle(AccessToken)
Backend -> GoogleAuth : GetUserInfoByToken
alt Token Valid
    GoogleAuth --> Backend -- : UserInfo
    
    Backend -> Database ++ : CreateCustomerIfNotExist
    Database --> Backend : Customer

    Backend -> Database : CreateAuthGoogleIfNotExist(UserInfo.sid)
    note right of Database : Customer record is always returned.\nIf customer doesn't exist, customer\nis created first then returned.
    Database --> Backend  -- : AuthGoogle

    Backend -> Backend : Check AuthGoogle.sid == UserInfo.sid
    alt Auth Success
        Backend -> Backend : Issue two JWTs (Access Token & Refresh Token)
        Backend --> User : JWTs (Access Token & Refresh Token)
    else Auth Failure
        Backend --> User : Permission Denied
    end
else Token Invalid
    GoogleAuth --> Backend : GetUserInfoByToken Error
    Backend --> User -- : Permission Denied
end

@enduml

@startuml Send Welcome Email
actor System
participant EmailServer
database Database

activate System

System -> Database ++ : FetchUserInfo

Database --> System -- : UserData

System -> System : Get Magic Link Template
System -> System : Fill Magic Link Template by UserData

System -> EmailServer ++ : SendEmail(Filled Magic Link Template)
EmailServer --> System -- : EmailSentResponse

@enduml

@startuml Logout
actor User

activate User

User -> User : Delete JWTs (Access Token & Refresh Token) from device

@enduml

@startuml Connect Calendar
actor User
participant "Jadwal App" as App
participant "Backend" as Backend
participant "iOS Settings" as Settings
participant "iOS Calendar" as Calendar
participant "Baikal Server" as Baikal

activate User

User -> App ++ : Tap "Easy Setup"
App -> Backend ++ : Request Magic Token (CalDAV)
Backend --> App -- : Return Magic Token

App -> Backend ++ : Request .mobileconfig profile\nwith Magic Token
Backend --> App -- : Return .mobileconfig profile

App -> Settings ++ : Open profile installation

Settings -> User : Request profile approval
alt User Approves Profile
    User -> Settings : Approve profile
    
    Settings -> Calendar ++ : Configure CalDAV account
    alt Configuration Succeeds
        Calendar -> Baikal ++ : Verify connection
        Baikal --> Calendar -- : Connection verified
        Calendar --> Settings -- : Account configured
        Settings --> App -- : Profile installed
        App --> User -- : Show success page
    else Configuration Fails
        Calendar --> Settings -- : Configuration error
        Settings --> App -- : Installation failed
        App --> User : Show error page\n"Calendar setup failed"
    end
else User Denies Profile
    User -> Settings : Deny profile
    Settings --> App -- : Profile denied
    App --> User : Show error page\n"Setup cancelled - Try again later"
end

deactivate User
@enduml

@startuml Create Calendar
actor User
participant "Jadwal App" as App
participant "EventKit" as EventKit

activate User

User -> App ++ : Tap Calendar icon
App --> User : Show Calendars sheet

User -> App : Tap plus icon
App --> User : Show calendar creation form

User -> App : Submit calendar details\n(name, account, color)

alt EventKit Access Authorized
    App -> EventKit ++ : Create Calendar
    alt Creation Succeeds
        EventKit --> App -- : Calendar added
        App --> User : Show success response
    else Creation Fails
        EventKit --> App -- : Creation error
        App --> User : Show error and retry option
    end
else EventKit Access Denied
    App --> User : Show prompt to\nenable calendar access
end

deactivate User
@enduml

@startuml Connect WhatsApp
actor User
participant "Jadwal App" as App
participant Backend
participant "Wasapp (WhatsApp) Service\n(uses whatsapp-web.js)" as Wasapp
participant "WhatsApp App" as WhatsAppApp

activate User

User -> App ++ : Click "Connect WhatsApp"
App --> User : Ask for WhatsApp phone number

User -> App : Enter phone number
App -> Backend ++ : InitiateWhatsApp(phone number)
Backend -> Wasapp ++ : Request linking code

alt Linking Code Generated Successfully
    Wasapp --> Backend -- : Return linking code
    Backend --> App -- : Show linking code
    App --> User : Display linking code

    alt User Enters Code
        User -> WhatsAppApp ++ : Enter code in WhatsApp app
        WhatsAppApp -> WhatsAppApp -- : Validate code
        
        alt Code Valid
            WhatsAppApp --> User : Show success message
            WhatsAppApp --> Wasapp : Send auth credentials
            Wasapp -> Wasapp : Store WhatsApp credentials
            Wasapp -> Backend : Send auth success
            Backend --> App : Connection successful
            App --> User : Show success screen
        else Code Invalid
            WhatsAppApp --> User : Show invalid code error
            WhatsAppApp --> Wasapp : Send auth failure
            Wasapp -> Backend : Send auth failure
            Backend --> App : Connection failed
            App --> User : Show "Invalid code" error
        end
        deactivate WhatsAppApp

    else User Cancels
        User -> App : Cancel connection
        App -> Backend : Cancel WhatsApp setup
        Backend -> Wasapp : Cancel linking code
        App --> User : Show "Setup cancelled" message
    end

else Request Failed
    Wasapp --> Backend -- : Request failed
    Backend --> App -- : Connection failed
    App --> User : Show error and retry option
end

deactivate User
@enduml

@startuml Extract Events from WhatsApp
actor "Wasapp (WhatsApp) Service\n(uses whatsapp-web.js)" as WhatsApp
queue "RabbitMQ\nMessage Queue" as MessageQueue
queue "RabbitMQ\nCalendar Queue" as CalendarQueue

participant "Message Consumer" as Consumer
participant "LLM Service" as LLM
participant "Calendar Consumer" as CalConsumer
database "Database\n(encrypted at rest)" as Database
participant "CalDAV Server\n(Baikal)" as Baikal
participant "APNs" as APN

activate WhatsApp
loop Listen for Non-Group Messages
    WhatsApp -> WhatsApp: Filter out group messages
    
    WhatsApp ->> MessageQueue: Publish message with details\n(ID, chat ID, sender, body, timestamp)
    
    MessageQueue -> Consumer ++: Consume message

    Consumer -> Database ++: Get chat history\n(encrypted with WhatsApp messages key)
    Database --> Consumer --: Return decrypted messages context
    
    Consumer -> LLM ++: Analyze with event detection prompt
    note right of LLM: Prompt analyzes for:\n- Event presence\n- Agreement status\n- Event details\n- Returns status:\n  NO_EVENT\n  HAS_EVENT_BUT_NOT_CONFIRMED\n  HAS_EVENT_AGREED\n  HAS_EVENT_DENIED
    
    alt \textit{HAS_EVENT_AGREED}
        LLM --> Consumer: Return Event JSON
        Consumer ->> CalendarQueue: Publish event
        
        CalendarQueue -> CalConsumer ++: Consume event
        
        CalConsumer -> Database ++: Get CalDAV credentials\n(encrypted with CalDAV password key)
        Database --> CalConsumer --: Return decrypted credentials
        
        CalConsumer -> Baikal ++: Initialize WhatsApp Events calendar\n(if needed)
        Baikal --> CalConsumer --: Calendar ready
        
        CalConsumer -> Baikal ++: Add event via CalDAV
        Baikal --> CalConsumer --: Event added
        
        CalConsumer -> APN ++: Send event notification
        APN --> CalConsumer --: Notification sent
        
        CalConsumer -> Database ++: Clear chat history
        Database --> CalConsumer --: Chat cleared
        deactivate CalConsumer
        
    else \textit{HAS_EVENT_DENIED}
        LLM --> Consumer: Event denied status
        Consumer -> Database ++: Clear chat history
        Database --> Consumer --: Chat cleared
        
    else \textit{HAS_EVENT_BUT_NOT_CONFIRMED}
        LLM --> Consumer: Not confirmed status
        note over Consumer: Continue monitoring chat
        
    else \textit{NO_EVENT}
        LLM --> Consumer --: No event status
        deactivate Consumer
    end
end

@enduml

@startuml Suggest Conflict Resolutions
actor System
database Database
participant "Apple Push Notification service (APNs)" as APN

activate System

System -> Database ++ : Check If Conflicts Exist Between Events
note right
  Checks for:
  1. Time overlap between events
  2. Available alternative time slots
end note
Database --> System : ConflictedEvents Result

alt ConflictedEvents are not empty
    System -> Database : GetResolutionOptions(ConflictedEvents)
    note right
      Options are:
      1. Move event to another time slot
      2. Keep both with conflict warning
    end note
    Database --> System : ResolutionOptions Result

    System -> Database : Ask For Device IDs Of Customer Owning Event
    Database --> System -- : Device IDs of Customer Owning Event

    System -> APN ++ : Send Push Notification "Telling User There is Conflict" to Device IDs
    note right: Includes both resolution options
    APN --> System -- : Push Notification Sending Result

else ConflictedEvents are empty
    note over System, Database : Do Nothing
end

@enduml

@startuml Manage Scheduling Conflicts
actor User
participant Backend
database Database
participant "Apple Push Notification service (APNs)" as APN

activate User

User -> Backend ++ : ViewConflicts

Backend -> Database ++ : FetchConflicts
Database --> Backend -- : ConflictsList

Backend -> Backend : GenerateResolutionOptions
Backend --> User -- : DisplayConflictsWithOptions

alt User Selects Resolution
    User -> Backend ++ : ResolveConflict(selectedOption)
    
    Backend -> Database ++ : UpdateEvents
    Database --> Backend -- : EventsUpdated
    
    Backend -> Database ++ : Ask For Device IDs Of Customer Owning Event
    Database --> Backend -- : Device IDs of Customer Owning Event
    
    Backend -> APN ++ : Send Push Notification "Conflict Resolved" to Device IDs
    APN --> Backend -- : Push Notification Sending Result
    
    Backend --> User : ConflictResolved
else User Rejects
    note over User, Backend : Do Nothing
end

deactivate User

@enduml

@startuml Add Event Manually
actor User
participant Backend
database Database
participant "Apple Push Notification service (APNs)" as APN

activate User

User -> Backend ++ : CreateEvent(eventDetails)

Backend -> Backend : ValidateEventDetails
alt Validation Success
    Backend -> Database ++ : StoreEvent
    Database --> Backend -- : EventStored
    
    Backend -> Backend : CheckForConflicts
    opt Conflicts Found
        Backend -> Database ++ : Ask For Device IDs Of Customer Owning Event
        Database --> Backend -- : Device IDs of Customer Owning Event
        
        Backend -> APN ++ : Send Push Notification "New Conflict Detected" to Device IDs
        APN --> Backend -- : Push Notification Sending Result
    end
    
    Backend --> User : EventCreated
else Validation Failed
    Backend --> User : ValidationError
end

deactivate User

@enduml

@startuml View Integrated Calendar
actor User
participant "Jadwal App" as App
participant "EventKit" as EventKit

activate User

User -> App ++ : Open Calendar View

alt EventKit Access Authorized
    App -> EventKit ++ : Request Calendars & Events
    EventKit --> App -- : Return Calendar Data
    
    App -> App : Apply view preferences
    App --> User : Display calendar view
    
    note right of App
      EventKit observer keeps
      view updated in real-time
    end note
else EventKit Access Denied
    App --> User : Show prompt to\nenable calendar access
end

deactivate User
@enduml

@startuml Schedule Prayer Times
actor User
participant Backend
participant "Prayer Times API" as PrayerTimesAPI
database Database

activate User
User -> Backend ++ : EnablePrayerTimeScheduling

Backend -> PrayerTimesAPI ++ : Fetch Prayer Times by User's Timezone
PrayerTimesAPI --> Backend -- : PrayerTimes

Backend -> Database ++ : Create Events to Block Times of Prayer
Database --> Backend -- : Creation Response

Backend --> User : EnablePrayerTimeScheduling Response

@enduml

@startuml Receive Event Notifications
actor System
database Database
participant "Apple Push Notification service (APNs)" as APN

activate System

loop Poll Every One Minute
    System -> Database ++ : Check Alarms Set for Events
    Database --> System : Return Active Alarms
    alt Active Alarms Found
        System -> Database : Ask For Device IDs Of Customer Owning Event
        Database --> System -- : Device IDs of Customer Owning Event
        
        loop For Every Event
            System -> APN ++  : Send Push Notification to Device IDs
            APN --> System -- : Push Notification Sending Result
        end
    else No Active Alarms
        note over System,Database : Continue Polling
    end
end

@enduml